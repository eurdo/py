# Python 算法零基礎 4.排序 ⑦ 桶排序

11224215 顏玉棠


選擇排序回顧

① 遍歷陣列：從索引 0 到 n-1（n 為陣列長度）。

② 每輪確定最小值：假設當前索引 i 為最小值索引 min_index。從 i+1 到 n-1 遍歷，若找到更小元素，則更新 min_index。

③ 交換元素：若 min_index ≠ i，則交換 arr[i] 與 arr[min_index]。


冒泡排序回顧

① 初始化：設陣列長度為 n。

② 外層迴圈：遍歷 i 從 0 到 n-1（共 n 輪）。

③ 內層迴圈：對於每輪 i，遍歷 j 從 0 到 n-i-2。

④ 比較與交換：若 arr[j] > arr[j+1]，則交換兩者。

⑤ 結束條件：重複步驟 2–4，直到所有輪次完成。


插入排序回顧

① 遍歷未排序元素：從索引 1 到 n-1。

② 保存當前元素：將 arr[i] 存入 current。

③ 元素後移：從已排序部分的末尾（索引 j = i-1）向前掃描，將比 current 大的元素後移，直到找到第一個不大於 current 的位置或掃描完所有元素。

④ 插入元素：將 current 放入 j+1 位置。


計數排序回顧

① 初始化：設陣列長度為 n，元素最大值為 r。建立長度為 r+1 的計數陣列 count，初始值皆為 0。

② 統計元素頻率：遍歷原陣列 arr，對每個元素 x，將 count[x] 加 1。

③ 重構有序陣列：初始化索引 index = 0。遍歷計數陣列 count，索引由 0 到 r，若 count[v] > 0，則將 v 放入原陣列 arr[index]，index += 1，並 count[v] -= 1，重複此步驟直到 count[v] 為 0。

④ 排序完成。


合併排序回顧
I. 遞迴分解列表

① 終止條件：若鏈結為空或只有一個節點，即 head is None 或 head.next is None，直接返回 head。

② 快慢指標找中點：slow 和 fast 均從頭結點開始，fast 每次移動兩步，slow 每次一步。當 fast 到達尾端，slow 則指向中間節點。

③ 分割鏈結：將 slow.next 指向後半部分的頭 head2，並將 slow.next = None，切開前後部分。

④ 遞迴排序前後子鏈結：對 head 和 head2 分別遞迴使用 mergesort。

II. 合併兩個有序列表

① 建立虛擬頭節點 zero，current 指向之。

② 遍歷 head1 和 head2，比較值，較小者連接至合併鏈結，移動相應指標，並將 current 向前。

③ 處理剩餘節點：將未遍歷完的鏈結接至末端。

④ 返回 zero.next 為合併後有序鏈結。


快速排序回顧
I. Partition 分區函數

① 隨機選擇基準元素：在 left 到 right 範圍隨機選取一個元素，作為基準值。

② 將基準元素交換到最左邊。

③ 執行分區操作：找右側中第一個小於基準值的元素，移至左邊；找左側中第一個大於基準值的元素，移至右邊。

④ 完成後，基準元素左右分別為較小或較大值，返回其最終位置。

II. 遞迴排序

① 設定終止條件：若 left >= right，終止遞迴。

② 執行分區函數以取得基準位置。

③ 對左子陣列和右子陣列分別遞迴執行 quickSort。


桶排序（Bucket Sort）

桶排序是一種基於計數的排序演算法，核心概念是先將數據分配至有限數量的「桶」中，然後對每個桶分別排序（可使用其他排序算法或繼續使用桶排序），最後合併所有桶內資料形成排序結果。


算法流程

1.設定固定數量的空桶。

2.將數據放入對應的桶中。

3.對每個非空桶進行排序。

4.合併所有不為空的桶資料，生成排序後的結果。


算法分析

時間複雜度：桶排序屬於組合型排序，其時間效率取決於各桶內部所使用的排序方法。
CSDN

空間複雜度：由於使用了額外的桶來存放元素，最壞情況下需要與元素數量等量的空間，因此空間複雜度為 
𝑂
(
𝑛
)
O(n)。


優點

排序速度快：適用於數值範圍明確的整數或浮點數排序，無需直接比較元素可以提高效率。

穩定性：桶排序保持原始資料相對順序不變，是穩定排序方式。


缺點

空間消耗大：當數據範圍廣時，需要的桶數量大幅增加，導致記憶體消耗高。

不適合大規模資料：儘管理論上時間複雜度優異，但在實際場景中使用桶排序於大規模資料排序不太實用。
CSDN
